

intrinsic Mod2GaloisMapPQM(X::CrvHyp : prec:=30) -> Any 
  {Given X/F such that Jac(X) is a PQM surface (O maximal for now), the 2-torsion 
  A[2] is free of rank 1 as an O/2-module. Let Q be an O/2-basis element. 
  Then we can write Q^sigma = a_sigma * Q for any sigma \in GalF. We return the map 
            GalF --> (O/2)^x,   sigma |--> a_sigma   
  where it factors through adjoining the 2-torsion field 
  and the endomorphism field to F.}

  CC:=ComplexField(prec);
  assert BaseRing(X) eq Rationals();
  assert IsSimplifiedModel(X);
  B1,B2,B3:=HeuristicEndomorphismAlgebra( X : CC:=true);
  assert IsQuaternionAlgebra(B2);

  f:=HyperellipticPolynomials(X);
  XR:=RiemannSurface(f,2 : Precision:=prec);

	QA2:=SplittingField(f);
  QA2:=NumberField(Polredabs(DefiningPolynomial(QA2)));
	L:=HeuristicEndomorphismFieldOfDefinition(X);
  L:=NumberField(Polredabs(DefiningPolynomial(L)));

	M:=Compositum(QA2,L);
  Mdef:=DefiningPolynomial(M);
  Mdefred:=Polredabs(Mdef);
  M:=NumberField(Mdefred);
	ooplaces:=InfinitePlaces(M);
	embC:=ooplaces[1];

  //These are the roots a_i of the hyperelliptic polynomial
  // [(a_2,0)] - [(a_1,0)] will be an O/2O-basis element of A[2](C)
  //after apply the Abel-Jacobi map. assert a1 is rational.
  frootsM:=[ a[1] : a in Roots(ChangeRing(f,M))];
  frootsC:=[ Evaluate(a,embC) : a in frootsM ];
  //assert frootsM[1] eq 0;

  assert exists(rat_root){ a : a in frootsM | IsCoercible(Rationals(),a) };
  assert IsCoercible(XR,[rat_root,0]);
  XR`BasePoint := XR![rat_root,0];
  

  endos:=HeuristicEndomorphismRepresentation( X : CC:=true);
  endosM2:=[ ChangeRing(m[1],CC) : m in endos ];
  endosM4:=[ ChangeRing(m[2],Rationals()) : m in endos ]; 
  Bmat:=MatrixAlgebra< Rationals(), 4 | endosM4 >;
  tr, B, maptoB := IsQuaternionAlgebra(Bmat);
  Obasis:=[ maptoB(b) : b in endosM4 ];
  O:=QuaternionOrder(Obasis);
  a,b,c,d:=Explode(endosM2);
  //assert IsMaximal(O);

	BPM:=ChangeRing(BigPeriodMatrix(XR),CC);
	P1:=ColumnSubmatrix(BPM,1,2);
  //precsmall:=5;
	Latendo:=RealLatticeOfPeriodMatrix(ChangeRing(PeriodMatrix(X),CC));

  Omod2:=quo(O,2);
  coefs := [ [w,x,y,z] : w,x,y,z in [0,1] ];
  Omod2_eltsCC:=[ (coef[1]*a + coef[2]*b + coef[3]*c + coef[4]*d) : coef in coefs ];
  Omod2_elts:=[ Omod2!(O!(coef[1]*Obasis[1] + coef[2]*Obasis[2] + coef[3]*Obasis[3] + coef[4]*Obasis[4])) : coef in coefs ];

  cyclic_module:=[];
  k:=1;
  while #cyclic_module lt 16 do
    //Q is an O/2O basis element coming from the roots of X after applying Abel-Jacobi 
    Q:=1/2*P1*AbelJacobi(XR![frootsC[k],0],XR`BasePoint);
    //1/2*P1 because this is the change of basis required from the small period matrix lattice to Latendo
    k:=k+1;
    twotorsion_points:=[ a*Q : a in Omod2_eltsCC ];
    //this is O_Q: the O-cyclic module generated by Q. 
    twotorsion_points_real:= [ RealVector(v) : v in twotorsion_points ];
    cyclic_module := [ twotorsion_points[i] : i in [1..#twotorsion_points] 
    | not(exists(e){ twotorsion_points[j] : j in [1..#twotorsion_points] | j lt i and IsCoercible(Latendo,Eltseq(twotorsion_points_real[i]-twotorsion_points_real[j])) }) ];
  end while;

  //check that they are all 2-torsion points, only the identity is already 2-torsion
  //and that O_Q is all of the two torsion
  assert forall(e){ x : x in twotorsion_points_real | IsCoercible(Latendo,Eltseq(2*x)) };
  assert #{ x : x in twotorsion_points_real | IsCoercible(Latendo,Eltseq(x)) } eq 1;
  assert not(exists(t){ [T1,T2] : T1,T2 in twotorsion_points_real | IsCoercible(Latendo,Eltseq(T1-T2)) and (T1 ne T2) });
  //cyclic_module := [ twotorsion_points[i] : i in [1..#twotorsion_points] 
    //| not(exists(e){ twotorsion_points[j] : j in [1..#twotorsion_points] | j lt i and IsCoercible(Latendo,Eltseq(twotorsion_points_real[i]-twotorsion_points_real[j])) }) ];

  Gal,auts,map:=AutomorphismGroup(M);

  map_init:=[];
  for sigma in Gal do
    //Qsigma is what we get when we act on Q by the Galois element sigma. It is still a two torsion point.
    Qsigma := 1/2*(P1)*AbelJacobi(XR![Evaluate(map(sigma)(frootsM[k-1]),embC),0], XR`BasePoint);
    cyclic_coefficients:=[ a : a in Omod2_eltsCC | IsCoercible(Latendo,Eltseq(RealVector(a*Q - Qsigma))) ];
    assert #cyclic_coefficients eq 1;
    index:=Index(Omod2_eltsCC,cyclic_coefficients[1]);
    a_sigma := Omod2_elts[index];
    Append(~map_init,<sigma,a_sigma>);
  end for;
  
  enhancedmap:=map< Gal -> Omod2_elts | map_init >;
  assert enhancedmap(Id(Gal)) eq Omod2![1,0,0,0];
  //enhancedmap:=map< Gal -> Omod2_elts | sigma :-> 
  //Omod2_elts[[ i : i in [1..#twotorsion_points] | IsCoercible(Latendo,Eltseq(RealVector(twotorsion_points[i] - 1/2*(P1)*AbelJacobi(XR![Evaluate(map(sigma)(frootsM[2]),embC),0])))) ][1]] >;

  return Gal,map,enhancedmap,O;
 end intrinsic;




 
 //R<x> := PolynomialRing(Rationals()); C := HyperellipticCurve(R![-1, 5, -8, 4, -1, 1], R![]);
 //X:=C;
 intrinsic EndomorphismRepresentationPQM(X::CrvHyp : prec:=30) -> Any 
  {}

  CC:=ComplexField(prec);
  assert BaseRing(X) eq Rationals();
  assert IsSimplifiedModel(X);
  B1,B2,B3:=HeuristicEndomorphismAlgebra( X : CC:=true);
  assert IsQuaternionAlgebra(B2);

  endos:=HeuristicEndomorphismRepresentation( X : CC:=true);
  endosM2:=[ ChangeRing(m[1],CC) : m in endos ];
  endosM4:=[ ChangeRing(m[2],Rationals()) : m in endos ]; 
  Bmat:=MatrixAlgebra< Rationals(), 4 | endosM4 >;
  tr, B, maptoB := IsQuaternionAlgebra(Bmat);
  Obasis:=[ maptoB(b) : b in endosM4 ];
  O:=QuaternionOrder(Obasis);
  //assert IsMaximal(O);
  //O:=MaximalOrder(QuaternionAlgebra(Discriminant(Oquat)));

  tr,mu:=HasPolarizedElementOfDegree(O,1);
  L:=HeuristicEndomorphismFieldOfDefinition(X);
  L:=OptimizedRepresentation(L);
  Gal,auts,map:=AutomorphismGroup(L);
  //assert GroupName(Gal) eq "C2^2";

  AutFull:=Aut(O,mu);
  wchi:=[ a : a in Generators(Domain(AutFull)) | Sprint(a) eq "w_chi" ][1];
  wmu:=[ a : a in Generators(Domain(AutFull)) | Sprint(a) eq "w_mu" ][1];  

  if IsCyclic(Gal) then 
    if #Gal in [4,6] then 
      sigma_mu:=Gal.1;
      elts:= [ <sigma_mu^l, wmu^l> : l in [0..#Gal/2-1] ];
      galmap_init:=map< Gal -> Domain(AutFull) | elts >;
      endomorphism_rep := galmap_init*AutFull;
      assert MapIsHomomorphism(endomorphism_rep : injective:=true);
    else
      return "Galois group is cyclic but not sure what to assign the generator yet";
    end if;
  end if;

  tr,muchi:=IsTwisting(O,mu);
  chi:=muchi[2];
  
  cycsubs_init := [ H`subgroup : H in Subgroups(Gal : IsCyclic:=true) | H`order in [2,#Gal/2] ]; 
  cycsubs := [ H : H  in cycsubs_init | forall(e){ G : G in Exclude(cycsubs_init,H) | H notin [ N`subgroup : N in Subgroups(G) ] } ];
  maybe_muchi := [ H.1 : H in cycsubs ];
  endos := [];
  for sigma in maybe_muchi do 
    Ksigma:=FixedField(L,[map(sigma)]);
    //Ksigma := OptimizedRepresentation(Ksigma);
      assert Degree(Ksigma) in [2,#Gal/2];
      Kprec:=BaseNumberFieldExtra(DefiningPolynomial(Ksigma),prec);

      XK:=ChangeRing(X,Kprec);
      A1,A2,A3:=HeuristicEndomorphismAlgebra(XK);
      tr,E:=IsNumberField(A2);
      assert tr;
      assert Degree(E) le 2;
      Append(~endos, <sigma, Ksigma,SquarefreeFactorization(Discriminant(E)) >);
      //Append(~fixedfields,Ksigma);
      //Append(~endo_discs, SquarefreeFactorization(Discriminant(E)));
    //end if;
  end for;

  tup_mu:=[ tup : tup in endos | SquarefreeFactorization(Rationals()!(mu^2)) eq tup[3] ];
  assert #tup_mu eq 1;
  sigma_mu := tup_mu[1][1];

  tup_chi:=[ tup : tup in endos | SquarefreeFactorization(Rationals()!(chi^2)) eq tup[3] ];
  assert #tup_chi eq 1;
  sigma_chi := tup_chi[1][1];

  assert Gal eq sub< Gal | sigma_mu, sigma_chi >;

  elts:= [ <sigma_mu^l*sigma_chi^k, wmu^l*wchi^k> : l in [0..#Gal/2-1], k in [0..1] ];
  galmap_init:=map< Gal -> Domain(AutFull) | elts >;
  endomorphism_rep := galmap_init*AutFull;
  assert MapIsHomomorphism(endomorphism_rep : injective:=true);

/*  AutFull:=Aut(O,mu);
  Autmuimage:=[ AutFull(c) : c in Domain(AutFull) ];
  Autmu_alg:= [ SquarefreeFactorization(Rationals()!((g^2)`element)) : g in Autmuimage ];
  Exclude(~Autmu_alg,1);
  Autmu_alg:=[1] cat Autmu_alg;

  fixedfields:=[];
  endo_discs:=[];
  Galelts:=Setseq(Set(Gal));
  for sigma in Galelts do 
    Ksigma:=FixedField(L,[map(sigma)]);
    if Degree(Ksigma) eq 2 then
      Kprec:=BaseNumberFieldExtra(DefiningPolynomial(Ksigma),prec);

      XK:=ChangeRing(X,Kprec);
      A1,A2,A3:=HeuristicEndomorphismAlgebra(XK);
      tr,E:=IsNumberField(A2);
      assert tr;
      assert Degree(E) le 2;
      Append(~fixedfields,Ksigma);
      Append(~endo_discs, SquarefreeFactorization(Discriminant(E)));
    end if;
  end for;

  fixedfields:=[L] cat fixedfields;
  endo_discs:=[1] cat endo_discs; //1 in endo discs corresponds to having QM over L, i.e. it is the trivial Galois element.

  //The map from the Galois group of L to the discriminant of the endomorphism field defined over the corresponding fixed field.
  auttoendo:=map< Gal -> endo_discs | sigma :-> endo_discs[([ i : i in [1..#fixedfields] | IsIsomorphic(fixedfields[i],FixedField(L,[map(sigma)])) ][1])] >; 
  //the map from the discriminant of the endomorphism field to Aut(mu,O).
  endotoautmuO := map< endo_discs -> Autmuimage | d :-> Autmuimage[Index(Autmu_alg,d)] >;

  endomorphism_rep:= auttoendo*endotoautmuO;
  assert MapIsHomomorphism(endomorphism_rep : injective:=true);*/

  return Gal, map, endomorphism_rep, O;

end intrinsic;



intrinsic EnhancedRepresentationMod2PQM(X::CrvHyp : prec:=30) -> Any 
  {return 1. the Galois group of the compositum of the two torsion field and the endomorphism field
          2. A map from the Galois group in S_n to automorphisms of the field
          3. the enhanced representation as a map from automorphisms of the field to elements of the enhanced semidirect product.
          4. the endomorphism ring}

  Galgrp2,Galmap2,mod2map,O1:=Mod2GaloisMapPQM(X : prec:=prec);
  Galgrp_end,Galmap_end,rho_end,O2:=EndomorphismRepresentationPQM(X : prec:=prec);

  //Let's check O1 and O2 are THE SAME, not just isomorphic. Note there is no such thing as O1 eq O2.
  assert StandardForm(QuaternionAlgebra(O1)) eq StandardForm(QuaternionAlgebra(O2));
  assert [ Eltseq(b) : b in Basis(O1) ] eq [ Eltseq(b) : b in Basis(O2) ];
  //We will work with O2 because the image of rho_end needs to be in O2 (because it's in the normalizer).

  M:=Domain(Galmap2(Galgrp2.1));
  L:=Domain(Galmap_end(Galgrp_end.1));

  assert IsSubfield(L,M);
  Galrel:=AutomorphismGroup(RelativeField(L,M));
  //IsIsomorphic(FixedField(M,[Galmap2(Galrel.2)]),L);
  Galrelquo,quomap:=quo< Galgrp2 | Galrel >;
  assert Galrelquo eq Galgrp_end;


  restrict_gal:= map< Galgrp2 -> Galgrp_end | sigma :-> quomap(sigma) >;
  restrict_rho_end:=restrict_gal*rho_end;

  /*Bmod2:=QuaternionAlgebra(Universe(Codomain(mod2map))`quaternionorder);
  Bend:=Universe(Codomain(rho_end))`quaternionalgebra;
  _,Bmap:=IsIsomorphic(Bend,Bmod2 : Isomorphism:=true);
  Bmod2modQx:=QuaternionAlgebraModuloScalars(Bmod2);

  B1,B2,B3:=HeuristicEndomorphismAlgebra( X : CC:=true);
  tr,B:=IsQuaternionAlgebra(B2);
  //O:=MaximalOrder(QuaternionAlgebra(Discriminant(B)));
  O:=Universe(Codomain(mod2map))`quaternionorder;*/
  B:=QuaternionAlgebra(O2);
  BxmodQx:=QuaternionAlgebraModuloScalars(B);
  Omod2:=quo(O2,2);
  Oenh:=EnhancedSemidirectProduct(O2 : N:=2);

  rho_enhanced:=map< Galgrp2 -> Oenh | sigma :-> < restrict_rho_end(sigma), Omod2!(O2!Eltseq(mod2map(sigma)`element)) >  >;

  assert MapIsHomomorphism(rho_enhanced : injective:=true);
  return Galgrp2, Galmap2, rho_enhanced, O2;
end intrinsic;
  

//Rx<x>:=PolynomialRing(Rationals()); fx:=-x^5+4*x^4-10*x^3+8*x^2-2*x; X:=HyperellipticCurve(fx);



